/*
 * Decompiled with CFR 0.152.
 */
package baritone;

import baritone.er;
import java.util.Locale;
import java.util.MissingResourceException;
import java.util.ResourceBundle;

/*
 * This class specifies class file version 49.0 but uses Java 6 signatures.  Assumed Java 6.
 * Duplicate member names - consider using --renamedupmembers true
 * Illegal identifiers - consider using --renameillegalidents true
 */
public final class es
extends Enum<es>
implements er {
    private static /* enum */ es k = new es("Argument {0} outside domain [{1} ; {2}]");
    private static /* enum */ es l = new es("array size cannot be greater than {0}");
    private static /* enum */ es m = new es("array sizes should have difference 1 ({0} != {1} + 1)");
    private static /* enum */ es n = new es("array sums to zero");
    private static /* enum */ es o = new es("eigen decomposition of assymetric matrices not supported yet");
    private static /* enum */ es p = new es("matrix must have at least one column");
    private static /* enum */ es q = new es("matrix must have at least one row");
    private static /* enum */ es r = new es("bandwidth ({0})");
    private static /* enum */ es s = new es("Bessel function of order {0} cannot be computed for x = {1}");
    private static /* enum */ es t = new es("Bessel function of order {0} failed to converge for x = {1}");
    private static /* enum */ es u = new es("must have n >= k for binomial coefficient (n, k), got k = {0}, n = {1}");
    private static /* enum */ es v = new es("must have n >= 0 for binomial coefficient (n, k), got n = {0}");
    private static /* enum */ es w = new es("statistics constructed from external moments cannot be cleared");
    private static /* enum */ es x = new es("cannot compute 0-th root of unity, indefinite result");
    private static /* enum */ es y = new es("cannot compute beta density at 0 when alpha = {0,number}");
    private static /* enum */ es z = new es("cannot compute beta density at 1 when beta = %.3g");
    private static /* enum */ es A = new es("cannot compute nth root for null or negative n: {0}");
    private static /* enum */ es B = new es("cannot discard a negative number of elements ({0})");
    private static /* enum */ es C = new es("cannot format a {0} instance as a 3D vector");
    private static /* enum */ es D = new es("cannot format a {0} instance as a complex number");
    private static /* enum */ es E = new es("cannot format a {0} instance as a real vector");
    private static /* enum */ es F = new es("cannot format given object as a fraction number");
    private static /* enum */ es G = new es("statistics constructed from external moments cannot be incremented");
    private static /* enum */ es H = new es("cannot normalize a zero norm vector");
    private static /* enum */ es I = new es("elements cannot be retrieved from a negative array index {0}");
    private static /* enum */ es J = new es("cannot set an element at a negative index {0}");
    private static /* enum */ es K = new es("cannot substitute an element from an empty array");
    private static /* enum */ es L = new es("Conversion Exception in Transformation: {0}");
    private static /* enum */ es M = new es("Cardan angles singularity");
    private static /* enum */ es N = new es("class ({0}) does not implement Comparable");
    private static /* enum */ es O = new es("too close vertices near point ({0}, {1}, {2})");
    private static /* enum */ es P = new es("the closest orthogonal matrix has a negative determinant {0}");
    private static /* enum */ es Q = new es("column index {0} out of allowed range [{1}, {2}]");
    private static /* enum */ es R = new es("column index ({0})");
    private static /* enum */ es S = new es("constraint");
    private static /* enum */ es T = new es("Continued fraction convergents diverged to +/- infinity for value {0}");
    private static /* enum */ es U = new es("Continued fraction diverged to NaN for value {0}");
    private static /* enum */ es V = new es("contraction criteria ({0}) smaller than the expansion factor ({1}).  This would lead to a never ending loop of expansion and contraction as a newly expanded internal storage array would immediately satisfy the criteria for contraction.");
    private static /* enum */ es W = new es("contraction criteria smaller than one ({0}).  This would lead to a never ending loop of expansion and contraction as an internal storage array length equal to the number of elements would satisfy the contraction criteria.");
    private static /* enum */ es X = new es("convergence failed");
    private static /* enum */ es Y = new es("some outline boundary loops cross each other");
    private static /* enum */ es Z = new es("crossover rate ({0})");
    private static /* enum */ es aa = new es("Cumulative probability function returned NaN for argument {0} p = {1}");
    private static /* enum */ es ab = new es("some rows have length {0} while others have length {1}");
    private static /* enum */ es ac = new es("original and permuted data must contain the same elements");
    private static /* enum */ es ad = new es("digest not initialized");
    private static /* enum */ es ae = new es("got {0}x{1} but expected {2}x{3}");
    public static final /* enum */ es a = new es("{0} != {1}");
    private static /* enum */ es af = new es("dimensions mismatch");
    private static /* enum */ es ag = new es("Discrete cumulative probability function returned NaN for argument {0}");
    private static /* enum */ es ah = new es("distribution not loaded");
    private static /* enum */ es ai = new es("duplicated abscissa {0} causes division by zero");
    private static /* enum */ es aj = new es("edge joining points ({0}, {1}, {2}) and ({3}, {4}, {5}) is connected to one facet only");
    private static /* enum */ es ak = new es("elitism rate ({0})");
    private static /* enum */ es al = new es("empty cluster in k-means");
    private static /* enum */ es am = new es("sample for interpolation is empty");
    public static final /* enum */ es b = new es("empty polynomials coefficients array");
    private static /* enum */ es an = new es("empty selected column index array");
    private static /* enum */ es ao = new es("empty selected row index array");
    private static /* enum */ es ap = new es("empty string for imaginary character");
    private static /* enum */ es aq = new es("endpoints do not specify an interval: [{0}, {1}]");
    private static /* enum */ es ar = new es("equal vertices {0} and {1} in simplex configuration");
    private static /* enum */ es as = new es("Euler angles singularity");
    private static /* enum */ es at = new es("evaluation");
    private static /* enum */ es au = new es("expansion factor smaller than one ({0})");
    private static /* enum */ es av = new es("facets orientation mismatch around edge joining points ({0}, {1}, {2}) and ({3}, {4}, {5})");
    private static /* enum */ es aw = new es("must have n >= 0 for n!, got n = {0}");
    private static /* enum */ es ax = new es("number of iterations={4}, maximum iterations={5}, initial={6}, lower bound={7}, upper bound={8}, final a value={0}, final b value={1}, f(a)={2}, f(b)={3}");
    private static /* enum */ es ay = new es("Unable to convert {0} to fraction after {1} iterations");
    private static /* enum */ es az = new es("first {0} columns are not initialized yet");
    private static /* enum */ es aA = new es("first element is not 0: {0}");
    private static /* enum */ es aB = new es("first {0} rows are not initialized yet");
    private static /* enum */ es aC = new es("Overflow trying to convert {0} to fraction ({1}/{2})");
    private static /* enum */ es aD = new es("function is not differentiable");
    private static /* enum */ es aE = new es("function is not polynomial");
    private static /* enum */ es aF = new es("overflow: gcd({0}, {1}) is 2^31");
    private static /* enum */ es aG = new es("overflow: gcd({0}, {1}) is 2^63");
    private static /* enum */ es aH = new es("{0} wide hole between models time ranges");
    private static /* enum */ es aI = new es("condition number {1} is too high ");
    private static /* enum */ es aJ = new es("inconsistent state at 2\u03c0 wrapping");
    private static /* enum */ es aK = new es("the index specified: {0} is larger than the current maximal index {1}");
    private static /* enum */ es aL = new es("index ({0}) is not positive");
    private static /* enum */ es aM = new es("index {0} out of allowed range [{1}, {2}]");
    private static /* enum */ es aN = new es("index ({0})");
    private static /* enum */ es aO = new es("{0} is not a finite number");
    private static /* enum */ es aP = new es("interval bounds must be finite");
    private static /* enum */ es aQ = new es("value {0} at index {1}");
    private static /* enum */ es aR = new es("Array contains an infinite element, {0} at index {1}");
    private static /* enum */ es aS = new es("cannot convert infinite value");
    private static /* enum */ es aT = new es("initial capacity ({0}) is not positive");
    private static /* enum */ es aU = new es("initial column {1} after final column {0}");
    private static /* enum */ es aV = new es("initial row {1} after final row {0}");
    @Deprecated
    private static /* enum */ es aW = new es("input data comes from unsupported datasource: {0}, supported sources: {1}, {2}");
    private static /* enum */ es aX = new es("instance of class {0} not comparable to existing values");
    private static /* enum */ es aY = new es("insufficient data");
    private static /* enum */ es aZ = new es("insufficient data for t statistic, needs at least 2, got {0}");
    private static /* enum */ es ba = new es("insufficient dimension {0}, must be at least {1}");
    private static /* enum */ es bb = new es("dimension ({0})");
    private static /* enum */ es bc = new es("sample contains {0} observed points, at least {1} are required");
    private static /* enum */ es bd = new es("insufficient data: only {0} rows and {1} columns.");
    private static /* enum */ es be = new es("multistep method needs at least {0} previous steps, got {1}");
    public static final /* enum */ es c = new es("internal error, please fill a bug report at {0}");
    private static /* enum */ es bf = new es("invalid binary digit: {0}");
    private static /* enum */ es bg = new es("binary mutation works on BinaryChromosome only");
    private static /* enum */ es bh = new es("invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}");
    private static /* enum */ es bi = new es("one-point crossover only works with fixed-length chromosomes");
    private static /* enum */ es bj = new es("required functionality is missing in {0}");
    private static /* enum */ es bk = new es("invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}");
    private static /* enum */ es bl = new es("invalid iteration limits: min={0}, max={1}");
    private static /* enum */ es bm = new es("bad value for maximum iterations number: {0}");
    private static /* enum */ es bn = new es("the number of observations is not sufficient to conduct regression");
    private static /* enum */ es bo = new es("input data array length = {0} does not match the number of observations = {1} and the number of regressors = {2}");
    private static /* enum */ es bp = new es("length of regressor array = {0} does not match the number of variables = {1} in the model");
    private static /* enum */ es bq = new es("invalid rounding method {0}, valid methods: {1} ({2}), {3} ({4}), {5} ({6}), {7} ({8}), {9} ({10}), {11} ({12}), {13} ({14}), {15} ({16})");
    private static /* enum */ es br = new es("iterator exhausted");
    private static /* enum */ es bs = new es("iterations");
    private static /* enum */ es bt = new es("overflow: lcm({0}, {1}) is 2^31");
    private static /* enum */ es bu = new es("overflow: lcm({0}, {1}) is 2^63");
    private static /* enum */ es bv = new es("list of chromosomes bigger than maxPopulationSize");
    private static /* enum */ es bw = new es("Loess expects at least 1 point");
    private static /* enum */ es bx = new es("lower bound ({0}) must be strictly less than upper bound ({1})");
    private static /* enum */ es by = new es("lower endpoint ({0}) must be less than or equal to upper endpoint ({1})");
    private static /* enum */ es bz = new es("map has been modified while iterating");
    private static /* enum */ es bA = new es("multistep integrator starter stopped early, maybe too large step size");
    private static /* enum */ es bB = new es("evaluations");
    private static /* enum */ es bC = new es("maximal count ({0}) exceeded");
    private static /* enum */ es bD = new es("maximal number of iterations ({0}) exceeded");
    private static /* enum */ es bE = new es("minimal step size ({1,number,0.00E00}) reached, integration needs {0,number,0.00E00}");
    private static /* enum */ es bF = new es("Loess expects the abscissa and ordinate arrays to be of the same size, but got {0} abscissae and {1} ordinatae");
    private static /* enum */ es bG = new es("mutation rate ({0})");
    private static /* enum */ es bH = new es("element {0} is NaN");
    private static /* enum */ es bI = new es("cannot convert NaN value");
    private static /* enum */ es bJ = new es("brightness exponent should be positive or null, but got {0}");
    private static /* enum */ es bK = new es("negative complex module {0}");
    private static /* enum */ es bL = new es("element ({0}, {1}) is negative: {2}");
    private static /* enum */ es bM = new es("element {0} is negative: {1}");
    private static /* enum */ es bN = new es("number of successes must be non-negative ({0})");
    private static /* enum */ es bO = new es("number of successes ({0})");
    private static /* enum */ es bP = new es("number of trials must be non-negative ({0})");
    private static /* enum */ es bQ = new es("number of interpolation points ({0})");
    private static /* enum */ es bR = new es("number of trials ({0})");
    private static /* enum */ es bS = new es("vertices do not form a convex hull in CCW winding");
    private static /* enum */ es bT = new es("hyperplanes do not define a convex region");
    private static /* enum */ es bU = new es("number of robustness iterations ({0})");
    private static /* enum */ es bV = new es("start position ({0})");
    private static /* enum */ es bW = new es("Continued fraction convergents failed to converge (in less than {0} iterations) for value {1}");
    private static /* enum */ es bX = new es("non-invertible affine transform collapses some lines into single points");
    private static /* enum */ es bY = new es("number of microsphere elements must be positive, but got {0}");
    private static /* enum */ es bZ = new es("polynomial degree must be positive: degree={0}");
    private static /* enum */ es ca = new es("all abscissae must be finite real numbers, but {0}-th is {1}");
    private static /* enum */ es cb = new es("all ordinatae must be finite real numbers, but {0}-th is {1}");
    private static /* enum */ es cc = new es("all weights must be finite real numbers, but {0}-th is {1}");
    private static /* enum */ es cd = new es("non square ({0}x{1}) matrix");
    private static /* enum */ es ce = new es("Norm ({0})");
    private static /* enum */ es cf = new es("Cannot normalize to an infinite value");
    private static /* enum */ es cg = new es("Cannot normalize to NaN");
    private static /* enum */ es ch = new es("{0}x{1} and {2}x{3} matrices are not addition compatible");
    private static /* enum */ es ci = new es("points {0} and {1} are not decreasing ({2} < {3})");
    private static /* enum */ es cj = new es("points {3} and {2} are not decreasing ({1} < {0})");
    private static /* enum */ es ck = new es("not enough data ({0} rows) for this many predictors ({1} predictors)");
    public static final /* enum */ es d = new es("spline partition must have at least {0} points, got {1}");
    private static /* enum */ es cl = new es("points {0} and {1} are not increasing ({2} > {3})");
    private static /* enum */ es cm = new es("points {3} and {2} are not increasing ({1} > {0})");
    private static /* enum */ es cn = new es("{0}x{1} and {2}x{3} matrices are not multiplication compatible");
    private static /* enum */ es co = new es("not positive definite matrix");
    private static /* enum */ es cp = new es("not positive definite matrix: diagonal element at ({1},{1}) is smaller than {2} ({0})");
    private static /* enum */ es cq = new es("non positive definite linear operator");
    private static /* enum */ es cr = new es("non self-adjoint linear operator");
    private static /* enum */ es cs = new es("non square ({0}x{1}) linear operator");
    private static /* enum */ es ct = new es("degrees of freedom ({0})");
    private static /* enum */ es cu = new es("degrees of freedom must be positive ({0})");
    private static /* enum */ es cv = new es("element {0} is not positive: {1}");
    private static /* enum */ es cw = new es("invalid exponent {0} (must be positive)");
    private static /* enum */ es cx = new es("number of elements should be positive ({0})");
    private static /* enum */ es cy = new es("base ({0})");
    private static /* enum */ es cz = new es("exponent ({0})");
    private static /* enum */ es cA = new es("length must be positive ({0})");
    private static /* enum */ es cB = new es("length ({0})");
    private static /* enum */ es cC = new es("mean must be positive ({0})");
    private static /* enum */ es cD = new es("mean ({0})");
    private static /* enum */ es cE = new es("number of sample is not positive: {0}");
    private static /* enum */ es cF = new es("number of samples ({0})");
    private static /* enum */ es cG = new es("permutation k ({0}) must be positive");
    private static /* enum */ es cH = new es("permutation size ({0}");
    private static /* enum */ es cI = new es("the Poisson mean must be positive ({0})");
    private static /* enum */ es cJ = new es("population size must be positive ({0})");
    private static /* enum */ es cK = new es("population size ({0})");
    private static /* enum */ es cL = new es("invalid row dimension: {0} (must be positive)");
    private static /* enum */ es cM = new es("sample size must be positive ({0})");
    private static /* enum */ es cN = new es("scale must be positive ({0})");
    private static /* enum */ es cO = new es("scale ({0})");
    private static /* enum */ es cP = new es("shape must be positive ({0})");
    private static /* enum */ es cQ = new es("shape ({0})");
    private static /* enum */ es cR = new es("standard deviation must be positive ({0})");
    private static /* enum */ es cS = new es("standard deviation ({0})");
    private static /* enum */ es cT = new es("upper bound must be positive ({0})");
    private static /* enum */ es cU = new es("window size must be positive ({0})");
    private static /* enum */ es cV = new es("{0} is not a power of 2");
    private static /* enum */ es cW = new es("{0} is not a power of 2, consider padding for fix");
    private static /* enum */ es cX = new es("{0} is not a power of 2 plus one");
    private static /* enum */ es cY = new es("points {0} and {1} are not strictly decreasing ({2} <= {3})");
    public static final /* enum */ es e = new es("points {3} and {2} are not strictly decreasing ({1} <= {0})");
    private static /* enum */ es cZ = new es("knot values must be strictly increasing");
    private static /* enum */ es da = new es("points {0} and {1} are not strictly increasing ({2} >= {3})");
    public static final /* enum */ es f = new es("points {3} and {2} are not strictly increasing ({1} >= {0})");
    private static /* enum */ es db = new es("{0}x{1} and {2}x{3} matrices are not subtraction compatible");
    private static /* enum */ es dc = new es("method not supported in dimension {0}");
    private static /* enum */ es dd = new es("not symmetric matrix");
    private static /* enum */ es de = new es("non symmetric matrix: the difference between entries at ({0},{1}) and ({1},{0}) is larger than {2}");
    private static /* enum */ es df = new es("no bin selected");
    private static /* enum */ es dg = new es("none of the {0} start points lead to convergence");
    public static final /* enum */ es g = new es("no data");
    private static /* enum */ es dh = new es("no degrees of freedom ({0} measurements, {1} parameters)");
    private static /* enum */ es di = new es("This distribution does not have a density function implemented");
    private static /* enum */ es dj = new es("no feasible solution");
    private static /* enum */ es dk = new es("no optimum computed yet");
    private static /* enum */ es dl = new es("Regression model must include at least one regressor");
    private static /* enum */ es dm = new es("no result available");
    private static /* enum */ es dn = new es("no entry at indices ({0}, {1}) in a {2}x{3} matrix");
    private static /* enum */ es do = new es("NaN is not allowed");
    public static final /* enum */ es h = new es("null is not allowed");
    private static /* enum */ es dp = new es("a null or zero length array not allowed");
    private static /* enum */ es dq = new es("covariance matrix");
    private static /* enum */ es dr = new es("denominator");
    private static /* enum */ es ds = new es("denominator format");
    private static /* enum */ es dt = new es("fraction");
    private static /* enum */ es du = new es("function");
    private static /* enum */ es dv = new es("imaginary format");
    private static /* enum */ es dw = new es("input array");
    private static /* enum */ es dx = new es("numerator");
    private static /* enum */ es dy = new es("numerator format");
    private static /* enum */ es dz = new es("conversion exception in transformation");
    private static /* enum */ es dA = new es("real format");
    private static /* enum */ es dB = new es("whole format");
    private static /* enum */ es dC = new es("{0} is larger than the maximum ({1})");
    private static /* enum */ es dD = new es("{0} is smaller than the minimum ({1})");
    private static /* enum */ es dE = new es("{0} is larger than, or equal to, the maximum ({1})");
    private static /* enum */ es dF = new es("{0} is smaller than, or equal to, the minimum ({1})");
    private static /* enum */ es dG = new es("number of successes ({0}) must be less than or equal to population size ({1})");
    private static /* enum */ es dH = new es("overflow, numerator too large after multiply: {0}");
    private static /* enum */ es dI = new es("{0} points Legendre-Gauss integrator not supported, number of points must be in the {1}-{2} range");
    private static /* enum */ es dJ = new es("observed counts are all 0 in observed array {0}");
    private static /* enum */ es dK = new es("observed counts are both zero for entry {0}");
    private static /* enum */ es dL = new es("the difference between the upper and lower bound must be larger than twice the initial trust region radius ({0})");
    private static /* enum */ es dM = new es("out of bounds quantile value: {0}, must be in (0, 100]");
    private static /* enum */ es dN = new es("out of bounds confidence level {0}, must be between {1} and {2}");
    private static /* enum */ es dO = new es("out of bounds significance level {0}, must be between {1} and {2}");
    private static /* enum */ es dP = new es("significance level ({0})");
    private static /* enum */ es dQ = new es("the abscissae array must be sorted in a strictly increasing order, but the {0}-th element is {1} whereas {2}-th is {3}");
    private static /* enum */ es dR = new es("point ({0}, {1}, {2}) is out of plane");
    private static /* enum */ es dS = new es("out of range root of unity index {0} (must be in [{1};{2}])");
    private static /* enum */ es dT = new es("out of range");
    public static final /* enum */ es i = new es("{0} out of [{1}, {2}] range");
    private static /* enum */ es dU = new es("{0} out of ({1}, {2}] range");
    private static /* enum */ es dV = new es("{0} out of [{1}, {2}) range");
    private static /* enum */ es dW = new es("an outline boundary loop is open");
    private static /* enum */ es dX = new es("overflow");
    private static /* enum */ es dY = new es("overflow in fraction {0}/{1}, cannot negate");
    private static /* enum */ es dZ = new es("overflow in addition: {0} + {1}");
    private static /* enum */ es ea = new es("overflow in subtraction: {0} - {1}");
    private static /* enum */ es eb = new es("overflow in multiplication: {0} * {1}");
    private static /* enum */ es ec = new es("cannot access {0} method in percentile implementation {1}");
    private static /* enum */ es ed = new es("percentile implementation {0} does not support {1}");
    private static /* enum */ es ee = new es("permutation size ({0}) exceeds permuation domain ({1})");
    private static /* enum */ es ef = new es("polynomial");
    private static /* enum */ es eg = new es("number of polynomial interpolants must match the number of segments ({0} != {1} - 1)");
    private static /* enum */ es eh = new es("population limit has to be positive");
    private static /* enum */ es ei = new es("cannot raise an integral value to a negative power ({0}^{1})");
    private static /* enum */ es ej = new es("propagation direction mismatch");
    private static /* enum */ es ek = new es("RandomKeyMutation works only with RandomKeys, not {0}");
    private static /* enum */ es el = new es("roots of unity have not been computed yet");
    private static /* enum */ es em = new es("a {0}x{1} matrix cannot be a rotation matrix");
    private static /* enum */ es en = new es("row index {0} out of allowed range [{1}, {2}]");
    private static /* enum */ es eo = new es("row index ({0})");
    private static /* enum */ es ep = new es("function values at endpoints do not have different signs, endpoints: [{0}, {1}], values: [{2}, {3}]");
    private static /* enum */ es eq = new es("sample size ({0}) exceeds collection size ({1})");
    private static /* enum */ es er = new es("sample size ({0}) must be less than or equal to population size ({1})");
    private static /* enum */ es es = new es("simplex must contain at least one point");
    private static /* enum */ es et = new es("{0}");
    private static /* enum */ es eu = new es("matrix is singular");
    private static /* enum */ es ev = new es("operator is singular");
    private static /* enum */ es ew = new es("subarray ends after array end");
    private static /* enum */ es ex = new es("cutoff singular value is {0}, should be at most {1}");
    private static /* enum */ es ey = new es("tournament arity ({0}) cannot be bigger than population size ({1})");
    private static /* enum */ es ez = new es("cannot discard {0} elements from a {1} elements array");
    private static /* enum */ es eA = new es("too many regressors ({0}) specified, only {1} in the model");
    private static /* enum */ es eB = new es("cost relative tolerance is too small ({0}), no further reduction in the sum of squares is possible");
    private static /* enum */ es eC = new es("too small integration interval: length = {0}");
    private static /* enum */ es eD = new es("orthogonality tolerance is too small ({0}), solution is orthogonal to the jacobian");
    private static /* enum */ es eE = new es("parameters relative tolerance is too small ({0}), no further improvement in the approximate solution is possible");
    private static /* enum */ es eF = new es("trust region step has failed to reduce Q");
    private static /* enum */ es eG = new es("two or more categories required, got {0}");
    private static /* enum */ es eH = new es("two or more values required in each category, one has {0}");
    private static /* enum */ es eI = new es("unable to bracket optimum in line search");
    private static /* enum */ es eJ = new es("unable to compute covariances: singular problem");
    private static /* enum */ es eK = new es("unable to first guess the harmonic coefficients");
    private static /* enum */ es eL = new es("unable to orthogonalize matrix in {0} iterations");
    private static /* enum */ es eM = new es("unable to perform Q.R decomposition on the {0}x{1} jacobian matrix");
    private static /* enum */ es eN = new es("unable to solve: singular problem");
    private static /* enum */ es eO = new es("unbounded solution");
    private static /* enum */ es eP = new es("unknown mode {0}, known modes: {1} ({2}), {3} ({4}), {5} ({6}), {7} ({8}), {9} ({10}) and {11} ({12})");
    private static /* enum */ es eQ = new es("unknown parameter {0}");
    private static /* enum */ es eR = new es("ode does not match the main ode set in the extended set");
    private static /* enum */ es eS = new es("string \"{0}\" unparseable (from position {1}) as an object of type {2}");
    private static /* enum */ es eT = new es("string \"{0}\" unparseable (from position {1})");
    private static /* enum */ es eU = new es("unparseable 3D vector: \"{0}\"");
    private static /* enum */ es eV = new es("unparseable complex number: \"{0}\"");
    private static /* enum */ es eW = new es("unparseable real vector: \"{0}\"");
    private static /* enum */ es eX = new es("unsupported expansion mode {0}, supported modes are {1} ({2}) and {3} ({4})");
    private static /* enum */ es eY = new es("unsupported operation");
    private static /* enum */ es eZ = new es("arithmetic exception");
    public static final /* enum */ es j = new es("illegal state");
    private static /* enum */ es fa = new es("exception generated in user code");
    private static /* enum */ es fb = new es("URL {0} contains no data");
    private static /* enum */ es fc = new es("{0} values have been added before statistic is configured");
    private static /* enum */ es fd = new es("vector length mismatch: got {0} but expected {1}");
    private static /* enum */ es fe = new es("vector must have at least one element");
    private static /* enum */ es ff = new es("weigth array must contain at least one non-zero value");
    private static /* enum */ es fg = new es("wrong array shape (block length = {0}, expected {1})");
    private static /* enum */ es fh = new es("{0} points are required, got only {1}");
    private static /* enum */ es fi = new es("number of points ({0})");
    private static /* enum */ es fj = new es("denominator must be different from 0");
    private static /* enum */ es fk = new es("zero denominator in fraction {0}/{1}");
    private static /* enum */ es fl = new es("the fraction to divide by must not be zero: {0}/{1}");
    private static /* enum */ es fm = new es("zero norm");
    private static /* enum */ es fn = new es("zero norm for rotation axis");
    private static /* enum */ es fo = new es("zero norm for rotation defining vector");
    private static /* enum */ es fp = new es("zero not allowed here");
    private final String a;
    private static final /* synthetic */ es[] a;

    public static es[] values() {
        return (es[])a.clone();
    }

    public static es valueOf(String string) {
        return Enum.valueOf(es.class, string);
    }

    private es(String string2) {
        this.a = string2;
    }

    @Override
    public final String a(Locale locale) {
        try {
            Object object = es.class.getName().replaceAll("\\.", "/");
            object = ResourceBundle.getBundle("assets/".concat(String.valueOf(object)), locale);
            if (((ResourceBundle)object).getLocale().getLanguage().equals(locale.getLanguage())) {
                return ((ResourceBundle)object).getString(this.toString());
            }
        }
        catch (MissingResourceException missingResourceException) {}
        return this.a;
    }

    static {
        a = new es[]{k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, aa, ab, ac, ad, ae, a, af, ag, ah, ai, aj, ak, al, am, b, an, ao, ap, aq, ar, as, at, au, av, aw, ax, ay, az, aA, aB, aC, aD, aE, aF, aG, aH, aI, aJ, aK, aL, aM, aN, aO, aP, aQ, aR, aS, aT, aU, aV, aW, aX, aY, aZ, ba, bb, bc, bd, be, c, bf, bg, bh, bi, bj, bk, bl, bm, bn, bo, bp, bq, br, bs, bt, bu, bv, bw, bx, by, bz, bA, bB, bC, bD, bE, bF, bG, bH, bI, bJ, bK, bL, bM, bN, bO, bP, bQ, bR, bS, bT, bU, bV, bW, bX, bY, bZ, ca, cb, cc, cd, ce, cf, cg, ch, ci, cj, ck, d, cl, cm, cn, co, cp, cq, cr, cs, ct, cu, cv, cw, cx, cy, cz, cA, cB, cC, cD, cE, cF, cG, cH, cI, cJ, cK, cL, cM, cN, cO, cP, cQ, cR, cS, cT, cU, cV, cW, cX, cY, e, cZ, da, f, db, dc, dd, de, df, dg, g, dh, di, dj, dk, dl, dm, dn, do, h, dp, dq, dr, ds, dt, du, dv, dw, dx, dy, dz, dA, dB, dC, dD, dE, dF, dG, dH, dI, dJ, dK, dL, dM, dN, dO, dP, dQ, dR, dS, dT, i, dU, dV, dW, dX, dY, dZ, ea, eb, ec, ed, ee, ef, eg, eh, ei, ej, ek, el, em, en, eo, ep, eq, er, es, et, eu, ev, ew, ex, ey, ez, eA, eB, eC, eD, eE, eF, eG, eH, eI, eJ, eK, eL, eM, eN, eO, eP, eQ, eR, eS, eT, eU, eV, eW, eX, eY, eZ, j, fa, fb, fc, fd, fe, ff, fg, fh, fi, fj, fk, fl, fm, fn, fo, fp};
    }
}
